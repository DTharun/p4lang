/* Automatically generated by p4c-ebpf from ./test.p4i on Mon Jan  8 19:22:44 2018
 */
#include "./test.h"
#include <uapi/linux/bpf.h>
#include <uapi/linux/if_ether.h>
#include <uapi/linux/if_packet.h>
#include <uapi/linux/ip.h>
#include <linux/skbuff.h>
#include <linux/netdevice.h>
enum ebpf_errorCodes {
    NoError,
    PacketTooShort,
    NoMatch,
    StackOutOfBounds,
    HeaderTooShort,
    ParserTimeout,
};

#define EBPF_MASK(t, w) ((((t)(1)) << (w)) - (t)1)
#define BYTES(w) ((w) / 8)
#define write_partial(a, s, v) do { u8 mask = EBPF_MASK(u8, s); *((u8*)a) = ((*((u8*)a)) & ~mask) | (((v) >> (8 - (s))) & mask); } while (0)
#define write_byte(base, offset, v) do { *(u8*)((base) + (offset)) = (v); } while (0)

void* memcpy(void* dest, const void* src, size_t num);


int ebpf_filter(struct __sk_buff* skb){
    struct Headers_t headers = {
    };
    printk("%p", headers);
    unsigned ebpf_packetOffsetInBits = 0;
    enum ebpf_errorCodes ebpf_errorCode = NoError;
    void* ebpf_packetStart = skb;
    void* ebpf_packetEnd = (skb + skb->len);
    u8 pass = 0;
    u32 ebpf_zero = 0;
    unsigned char ebpf_byte;

    goto start;
    start: {
        goto accept;
    }

    reject: { return 1; }

    accept:
    {
        u8 hit;
        u8 x_0;
        {
x_0 = true;
            /* Reject()*/
{
pass = x_0;
            };
        }
    }
    ebpf_end:
    return pass;
}
